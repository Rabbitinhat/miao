##### HTML标准
  * p标签能否嵌套div标签？
    + 回答不能，说明是标准还是语义化

##### 基础CSS
  + 行内元素给顶height & width拿个属性不生效
  + csss动画， 一个圆，1s 线性 不停旋转 360°，口述代码
  + CSS为什么要在头部引入
  + 如果做lazy-load CSS要注意什么

##### javascript
  + 基础没怎么去问
  + vue的双向绑定原理
  + 在此基础上如何去观察一个数组的变化？(vue怎么做)
  + vue的生命周期中 actived是做什么的
  + vuex的利弊
  + vue-router中mode的两种模式是什么？ 为什么要这么做
##### 跨域相关
  + 见下方答案啊

##### webpack 相关
  + loader是什么， 什么作用
  + 有无自己写过loader
---
##### 双飞翼的实现方案
  * float
  * flex

##### 响应式：
  * rem: 视口宽度/视觉稿宽度乘10
  * media query 辅助，负责一些特殊机型的适配

##### css3 
  * 动画
  * 渐变

##### 作用域：
  * js查找变量的规则，
  * 作用域链就是这套规则的体现，从当前的词法作用域去

##### 闭包查找，如果找不到就上一层一层去找知道全局作用域
  * 一个函数在词法作用域之外调用，依然保持对原有词法作用域内变量的访问权限，行成闭包
  * 牵扯模块化
    - IIFE 立即执行函数表达式
    - 内部变量私有化，不与其他冲突
    - 暴露出来的只有一个接口，不关心内部实现，只关心外部调用

##### null  和 undefined的区别
  + 是js的两个基础变量
  + typeof null  === null
  + typeof undefined === undefined
  + undefined代表未定义， null则代表空值
  
##### this
  * this并非是谁调用就指向谁，而是在知性的过程中进行绑定的(动态作用域)。
  * 当然，改变this的指向的方法有很多，比如call apply bind之类的；
  * 最常见的莫过于实例化一个对象，也就是new
    - 创建一个全新的空对象
    - 然后讲该对象的__proto__指向构造函数的prototype
    - 将构造函数内部的this指向该对象
    - 如果没有实例化后没返回内容，就返回该对象自身
  * call apply bind 异同
    + 同为改变this指向的api
    
##### 原型：
  * 所有的引用类型，(数组，对象，函数)，都有对象特性，都有一个__proto__属性，指向的是它的构造函数的prototype值，是个普通的对象，除了null
  * 函数都有一个prototype属性，值是一个普通对象
  * 原型链，类似于作用域，当识图得到当前对象的一个属性，而这个对象上面又没有，就去它的构造函数中去查找，找到就返回。找不到就报错：XX is not defined

##### reduce 实现数组去重


##### 同步/异步
  * js为单线程，只能按部就班的顺序性执行任务
  * 事件类，timer等为异步操作
  * 延申到“事件循环模型”
    - 根据时间顺序将同步任务压入主线程的调用栈，依次执行
    - 一旦发现有事件等异步操作时，放入任务队列
    - 主线程解析完当前栈内的所有任务后，如果任务队列中有任务就去取出一个任务，压入主线程中执行
    - 接下来就是重复执行上面的操作，任务队列清空

##### 前端跨域
不要张口闭口JSONP，基本上说出来就是个背书答案。
  * 硬解决方案
    + Chrome store 有丰富的处理dev环境下解决跨域的插件
    + Chrome 可以主动开启跨域模式
    + 服务端做跨域处理
  * 软解决方案
    + 构建型项目，webpack-dev-server配置好proxy-table
    + 非构建型，JSONP吧，但是后端要写相应的回调

##### 双向绑定；
  * 设定监听器， 遍历数据对象，利用Object.defineProtptype重写get和set，同时添加订阅者
  * 如果订阅者过多话，需要一个消息订阅器来收集订阅器；
  * 一旦数据对象变更就由消息订阅者通知订阅者，并执行订阅者下的更新函数，达到视图更新；

##### 生命周期；
1.1：beforeCreate Vue实例初始化前期；
此时根节点以及数据对象都没有初始化；

1.2：created Vue实例初始化完成；
数据对象已经初始化成功，可以访问其中的数据，但DOM对还未生成

1.3 在created和beforeMount之间这个阶段，判断以何种方式来编译模板

2.1：beforeMount 挂载初期
此时的虚拟DOM已经生成，但真实DOM还没有，

2.2：mounted 挂载完成阶段
虚拟DOM经过经过编译生成了HTML，并且已经插入到真实的DOM中

3.1 beforeUpdete 数据变化出发更新之前，此时的视图还没有更新
3.2 update 视图更新完毕

4.1 beforeDestory 实例销毁初期，所有的数据绑定和事件，都即将解绑，都可以调用
4.4 destory 实例销毁后，只是一个DOM没有任何数据绑定，且依旧存在DOM中

##### 计算机网络
1. TCP协议的体系
  * 应用层 
    - TELNET FTP SMTP等
  * 运输层
    - TCP 或 UDP
  * 网际层IP
  * 网络接口层

2. 三次握手
    + 客户端发送一个连接请求给服务端，等待服务器反应；
    + 服务端接收到请求后，确认客户端的身份，返回一个数据包给客户端，等待客户端反应;
    + 客户端接受到该数据包后，向服务器发送确认数据包，TCP连接成功

3. 四次挥手
    + 客户端发送一个数据包，告知服务端关闭数据传送，进入等待断开的状态
    + 服务端收到后，返回一个ACK数据包，表示收到，
    + 当服务端数据传输完毕后，向客户端发送一个数据包表示关闭数据传送;
    + 客户端接受并发送ACK确认，断开TCP链接

输入URL到展现页面的过程？
+ 如果输入不全，那就由浏览器补全url；
+ 查找ip地址(包括浏览器缓存，系统缓存，路由器缓存)；
+ 浏览器向该IP地址发起HTTP请求
+ 服务器接受请求，处理并返回HTTP请求
+ 浏览器得到返回内容，开始解析
+ 异步加载资源，css  js img
+ 然后根据HTML 生成dom, 根据CSS生成CSSOM
+ 将两者结合生成renderTree
+ rendertree开始渲染和展示
+ 当遇到js时就阻塞渲染并执行js
+ js执行完毕后，再次渲染

##### webpack篇
  * 最好手动搭建一下项目结构，否则很容易出事
  * 入口(entry)，出口(output)，module(loader)，plugain(插件))
  * 模式，development || production。webpack当前版本这是一个必须设定的参数
  * webpack-dev-serber，cross-env，各种loaders
  * webpack的优化方案，主体依赖分离，extract，hash之类的

##### 重构方向
  * 先梳理业务流程，逻辑拆分，有助于js函数的抽象
  * 合理的HTML嵌套结构
  * 根据兼容情况写合适的CSS，但如果还让你去兼容IE8及一下，我建议你换一个
  * 尽量多的用公用方法，重复的方法没有写的必要
  * 注释清晰，利于维护

##### router
  * router的钩子函数
  * router的生命周期

##### virtul dom
  * 是什么？

##### 缓存
  * html 的内存
  * http的缓存
  * 如何正确处理缓存

##### 潜入H5页面
  * 与App如何通信
  * 微信分享

#### webpack 构建Vue项目
  * jsbridge
  * moke.  模拟数据
  * html5新标准
  * ES6
  * 可用性 可访问性了解
  * 如何自定义生成字体文件
  * wekit 图片格式
  * script 异步加载的方法
  * jQuery 
    - 核心思想
    - 事件委托
    - 插件机制
  * package.json 组成部分
  * css3 动画
  * 地图Map