## C6 TCP与UDP

### TCP

TCP transmission control protocol 传输控制协议

#### 特点

可靠传输

##### 确认应答

发送主机向接收主机发送数据, 当接收主机收到数据后, 会向发送主机发送一条已送达的确认消息
- ACK 确认应答 Positive Acknowledgement 表明已接收到消息
- NACK 否定确认应答(Negative Positive Acknowledgement) 已收到消息, 但信息无法理解

##### 重发控制

发送端通过接收到ACK来判断信息已经被接收, 如果一段时间未收到ACK时(可能是数据丢失, 也可能是ACK丢失), 就会重新发送数据

##### 重复控制

ACK丢失时, 接收主机可能会接收到重复的数据, 此时会丢弃重复数据

##### 序列号

TCP协议 将发送数据的每一个字节进行编号(初始值未随机值, 后续每有一个字节就在初始值上+1), 接收端查询数据中的序列号和数据长度(相加), 将**下一次应接收的序列号**作为确认应答返回

TCP数据长度 = IP协议首部中数据包长度 - IP首部长度 - TCP首部长度

#### 重发超时

超时的时间间隔一般根据数据往返时间(Round Trip Time RTT)和偏差值(RTT的变化值)进行调整

初始值一般为6s, 每次超时后, 等待时间会指数倍延长, 累积一定次数后, 强行中止连接并提示网络异常

### 连接管理

面向连接: 数据通信前先进行确认连接已建立

REVIEW 三次握手

### TCP 分段发送数据

`MSS` (Maximum Segment Size 最大消息长度)
TCP发送数据时, 将数据以`MSS`大小做分割

在三次握手阶段时, 双方发送请求(request)时, 会包含`MSS`的值(为双方接口适应的MSS的大小), 然后选择一个较小值使用(?)

### 使用窗口提高速度

按每段数据发送-确认操作进行传输时, 当数据传输时间较长时, 要等待确认在进行下一段数据发送的行为效率较低

窗口: 无需等待确认应答而可以继续发送的最大数据量

使用窗口, 每次发送数据时, 并不都进行确认, 而是在发送的总数据量到达窗口的限制大小时, 在统一发送确认消息

窗口以外的部分 => 已确认发送的数据段 + 未发送数据段

窗口机制应用了缓存技术

当数据发送后, 未收到确认应答时, 该数据仍会保存在发送主机的缓存中, 根据是否收到确认应答来判断进行重发还是删除操作

当收到确认应答时, 窗口会滑动到确认应答(下一次应接受的数据位置(序列号))的位置

当数据段发生丢失时, 主机会接收到不符合当前位置的数据段, 此时会发送请求符合当前位置的应答(ACK), 使用窗口时, 由于一次性会发送多条数据段, 因此发生丢失时可能收到多条ACK, 当同一个ACK次数累计为3时, 发送主机就会重新发送ACK请求的数据段(优于超时管理, **高速重发**)

#### 流控制

当接收主机处理当前数据包耗费时间较长时, 可能会影响下一条数据包的发送(丢弃)

流量控制 发送端根据接收端的实际接收能力控制发送的数据量进行数据发送

窗口大小有接收主机进行设置, 接收主机将当前**可接受数据的缓存区**大小放入TCP中, 表示窗口大小, 当窗口大小为0时, 发送端就会**停止发送新的数据包**, 并设置一个**定时器**等待接收主机方发送窗口更新的确认(缓存区的内容被释放), 当定时器到期时, 仍未接收到窗口更新的确认时, 就会发送一个只包含1个字节的**ZWP(Zero Window Probe)包**, 来询问窗口是否更新, 当收到包含新的窗口大小的确认时, 发送主机会继续进行发送. (累计发送3次ZWP, 仍未收到确认时, 就会断开连接?)

#### 拥塞控制

**网络拥塞** 由于网络中的主机都位于共享环境中, 每个主机并不专注于与某个主机的连接(?), 当网络由于其他主机的通信导致拥堵时, 再接收大量数据时可能会造成瘫痪(?)

慢启动: 通信开始时, 会设置一个拥塞窗口(初始为1MSS), 此时每发送一个数据包, 就会等待ACK(确认应答), 每收到一次ACK, 拥塞窗口就**增加1**(正常情况), 当发生超时重发时, 会设置慢启动阀(拥塞窗口的一半)

高速重发控制时, 慢启动阀值设置为此时窗口大小的一般, 窗口大小设置为慢启动阈值的大小+3个数据段

#### 提高网络利用率

延迟确认应答: 收到数据后不立即进行确认应答, 而是等待一段时间后再应答(通常每两个数据段应答一次)

捎带应答: 将确认应答和发送的数据作为一个数据包进行发送(但是应答只有等待接收数据处理完毕, 然后返回数据时才会发送)